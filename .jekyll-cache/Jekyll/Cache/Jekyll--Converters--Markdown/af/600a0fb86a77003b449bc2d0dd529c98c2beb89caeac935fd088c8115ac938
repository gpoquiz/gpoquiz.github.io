I"æ<iframe width="560" height="315" src="https://www.youtube.com/embed/BIJmYiCgFao" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>
<p>This project was mainly a means of learning Unreal Engine 4 (UE4).  As working with N‚Äôth dimensional arrays can become computationally expensive, I would probably try to use something lower level like OpenGL for a true research project. In any case, cellular automata are relatively easy to implement in any language, and so should provide a good opportunity to learn UE4.</p>

<p>To start with, an introduction to <a href="https://www.wikiwand.com/en/Cellular_automaton">Cellular Automata</a>. They are also called ‚Äú0 player games,‚Äù because you can imagine them as game boards that develop their states with 0 input.  They do this through adjacency conditions.  For example, the most famous cellular automata is <a href="https://www.wikiwand.com/en/Conway%27s_Game_of_Life">Conway‚Äôs Game of Life</a>, which has the conditions B3/S23.  A cell is ‚Äúborn‚Äù if it has 3 adjacencies. (where being born means the cell becomes active/alive), ‚Äúsurvives‚Äù if it has 2 or 3 adjacencies (there is no change in state), and ‚Äúdies‚Äù otherwise (the cell becomes inactive/dead).</p>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/e/e5/Gospers_glider_gun.gif" style="width: 25%; display: block;" /></p>

<p>There are an extreme number of rules in a D dimensional automata, specifically</p>

<p><code>
        <span>&Sigma;</span>
        i
</code> = (3<sup>d</sup> - 1)3<sup>d</sup> / 2</p>

<p>Where N = 3<sup>d</sup>. [Bays] [^1]</p>

<p>This makes rules like Conway‚Äôs, where growth is limited but not stifled, exceedingly rare.</p>

<p>Beginning the project, I used the default ‚ÄúFirst Person Shooter‚Äù template.  I picked this template because I thought that being able to walk around a 3D automaton as it develops would be interesting. However, I didn‚Äôt touch any of the template at first.  First was the ‚ÄúGrid‚Äù of the automaton, and the ‚ÄúCells‚Äù it contains.</p>

<p>Most of the literature I read regarding cellular automata classified them in terms of their conditions: ‚ÄúBorn‚Äù and ‚ÄúSurvive‚Äù thought it would be easier to think about the cells having ‚ÄúBorn‚Äù and ‚ÄúDie‚Äù conditions instead.  This was the wrong move.  As an example, one ruleset for 3 dimensions is B45S5 (Born with 4,5 adjacencies, Survive with 5).This ruleset with my conditions is B45D12346789‚Ä¶26.  Much more cumbersome.  Born/Die was still usable (perhaps slightly moreso than Born/Survive) in terms of coding logic, and so I leave the refactor for a different day.</p>

<p>Programming an automaton is very easy.  All you need is a collection of cells (Organized in some way that you can check their adjacencies) and a collection of conditions.  My grid for this project is an Actor which includes a TArray of Cells (StaticMeshComponents).  The grid also includes TArrays for the born and die conditions.  The Cells use a simple normal map to give them a ‚Äúhollow‚Äù texture, as well as a gradient coloring to provide some sense of order.  Each cell toggles its visibility based its living state.</p>

<p>The real fun came when converting from a 3d automaton to a generalizable N‚Äôth Dimensional Automaton.  The first required modification is in counting adjacencies.  For the 3D model, I used a triple for loop to iterate through each dimension.  Nesting for loops doesn‚Äôt work when you don‚Äôt know how many dimensions you will have.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int adjacencyCount = 1;
for (int d : dimensions){adjacencyCount *= 3;}

int aliveCount = 0;
// go through each adjacency (3^D - 1 count)
for (int adjIndex = 0; adjIndex &lt;= adjacencyCount - 1; adjIndex++)
{

    // skip self
    if (adjIndex == adjacencyCount / 2)
        continue;
    int div = 1;

	// build the coordinates of the current adjacent index
    TArray&lt;int&gt; adj;
    for (int d = 0; d &lt; dimensions.Num(); d++)
    {
        int offset = adjIndex / div % 3 - 1;
        adj.Add(coords[d] + offset);
        div *= 3;
    }
 
    int index = coordsToIndex(adj);

    if (validIndex &amp;&amp; cells[index]-&gt;isAlive)
    {
        aliveCount++;
    }
}
return adjacencyCount;
</code></pre></div></div>

<p>Widths of 3:
<br />2D = i*3 + j
<br />3D = i*9 + j*3 + k</p>

<p>In general, the adjacencies around the index are contained in the 3 width hypercube of dimension D.  The offset is simply multiplied each time.  This same logic in reverse applies to converting coordinates to an index:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int index = 0;
int offset = 1;
for (int i = 0; i &lt; dimensions.Num(); i++)
{
    index += coords[i] * offset;
    offset *= dimensions[i];
}
return index;
</code></pre></div></div>

<p>The only difference is the coordinates are generalized, and so the offset depends on that row‚Äôs dimensionality.</p>

<p>After the grid and cells were conceptualized, I began implementing interaction with the grid.  The basic concept would be a voxel style block placement, where you can edit the cells as if you were connecting/stacking bricks.</p>

<p>Future Developments: Converting this project to learn OpenGL, Creating an   orthograpic-third person view would definitely be easier to use (would make for a nice tablet demo if it runs well.)</p>

<p>Bays, C. (1987). Candidates for the Game of Life in Three Dimensions. Complex Systems, (1). Retrieved September 24, 2020, from https://content.wolfram.com/uploads/sites/13/2018/02/01-3-1.pdf.
[1]: https://content.wolfram.com/uploads/sites/13/2018/02/01-3-1.pdf</p>
:ET